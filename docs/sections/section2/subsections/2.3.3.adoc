=== 2.3.3 Strategy Pattern
*Status: Added for Milestone 3 – Application of Techniques*

This section documents how the *Strategy Pattern* was applied in the routing subsystem of the Map Team. The original implementation used a hard-coded OSRMv1 router built into Leaflet. Milestone 3 required refactoring this design so the project could support multiple routing providers in the future (Google Maps, Mapbox, or a custom shortest-path engine) without changing existing controller code.

This section follows the same structure as <<_2_3_2_specification_pattern,Section 2.3.2 Specification Pattern>> and builds on the Architectural separation described in <<_2_2_architecture_and_layering,Section 2.2>>.

==== Before: Hard-Coded OSRMv1 Router
Originally, routing logic lived directly inside the Map Controller and called the Leaflet OSRMv1 provider explicitly:

[source,typescript]
----
async function getRoute(origin, destination) {
  const router = L.Routing.osrmv1({
    serviceUrl: "https://router.project-osrm.org/route/v1",
  });

  return new Promise((resolve, reject) => {
    router.route([origin, destination], (err, routes) => {
      if (err) reject(err);
      else resolve(routes[0]);
    });
  });
}
----

*Problems identified:*
- Controller was tightly coupled to **OSRMv1**.
- No room to switch to Google Maps, Mapbox, or a custom algorithm.
- Testing routing behavior required mocking Leaflet directly.
- Violated the *Open–Closed Principle* because adding a new router required modifying existing logic.

This tightly-coupled version made experimentation or provider comparison impossible.

==== New Insight
Routing is a behavior, and behaviors that vary should be encapsulated behind an interface — which is exactly what the Strategy Pattern provides.

The team realized that switching routing engines must:
- Happen **without rewriting controllers**.
- Support future provider additions.
- Allow local testing without depending on the OSRM server.
- Maintain the same `getRoute()` API for all strategies.

This led to introducing the `RoutingStrategy` interface.

==== After: RoutingStrategy Interface
A generic routing contract was introduced:

[source,typescript]
----
export interface RoutingStrategy {
  getRoute(origin: LatLng, destination: LatLng): Promise<RouteResult>;
}
----

The real, currently implemented strategy: **OSRMRoutingStrategy**.

[source,typescript]
----
export class OSRMRoutingStrategy implements RoutingStrategy {
  private router = L.Routing.osrmv1({
    serviceUrl: "https://router.project-osrm.org/route/v1",
  });

  async getRoute(origin, destination): Promise<RouteResult> {
    return new Promise((resolve, reject) => {
      this.router.route([origin, destination], (err, routes) => {
        if (err) reject(err);
        else resolve(routes[0]);
      });
    });
  }
}
----

Stub strategies added as *planned extension points* (documented for M3):

[source,typescript]
----
export class GoogleMapsRoutingStrategy implements RoutingStrategy {
  async getRoute(origin, destination) {
    throw new Error("Google Maps routing planned but not yet implemented.");
  }
}

export class MapboxRoutingStrategy implements RoutingStrategy {
  async getRoute(origin, destination) {
    throw new Error("Mapbox routing planned but not yet implemented.");
  }
}

export class CustomShortestPathStrategy implements RoutingStrategy {
  async getRoute(origin, destination) {
    throw new Error("Custom routing engine planned but not yet implemented.");
  }
}
----

Controller-level usage becomes independent of provider choice:

[source,typescript]
----
const routingStrategy: RoutingStrategy = new OSRMRoutingStrategy();
// Could later be changed to GoogleMapsRoutingStrategy with no controller edits

const route = await routingStrategy.getRoute(origin, destination);
----

This removes the hard-coded dependency and supports future routing flexibility.

==== UML Strategy Diagram
[plantuml]
----
@startuml
interface RoutingStrategy {
  +getRoute(origin, destination): Promise<RouteResult>
}

class OSRMRoutingStrategy
class GoogleMapsRoutingStrategy
class MapboxRoutingStrategy
class CustomShortestPathStrategy

RoutingStrategy <|.. OSRMRoutingStrategy
RoutingStrategy <|.. GoogleMapsRoutingStrategy
RoutingStrategy <|.. MapboxRoutingStrategy
RoutingStrategy <|.. CustomShortestPathStrategy

OSRMRoutingStrategy --> "uses" L.Routing.osrmv1
@enduml
----

==== Benefits Achieved
- **Decoupling:** Controllers no longer depend on OSRMv1.
- **Extensibility:** New providers can be added by implementing the interface.
- **Testability:** Strategies can be mocked independently of Leaflet.
- **Consistency:** All providers share the same method signature.
- **Alignment:** Follows architectural principles from <<_2_2_architecture_and_layering,Section 2.2>>.

==== Testing & Verification
- PlantUML renders without warnings.
- Code and names match the Map Team’s real OSRM integration.
- Future strategies documented without contradicting earlier sections.
- Controller routing logic is now compliant with the Strategy Pattern.
