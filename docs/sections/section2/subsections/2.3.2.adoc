=== *2.3.2 Application of Techniques*

This subsection presents the concrete techniques applied by the team during Milestone 3, demonstrating how the project evolved from scattered, duplicated logic to modular, intention-revealing, and maintainable structures. The examples below come from real improvements implemented by the Map, Auth, and Backend teams. Each example includes a before/after transformation aligned with Domain-Driven Design principles and the architectural rules described in <<_2_2_architecture_and_layering,Section 2.2 Architecture & Layering>>.

=== Specification Pattern: From Scattered Conditionals to Composable Rules

==== Before
Filtering logic in the Map and Listing domains was originally written using inline conditionals inside controllers, leading to duplication and tight coupling. Each filter—such as “Near Me,” “Open Now,” or “Category”—was evaluated manually:

[source,typescript]
----
function filterResults(listings, filters) {
  return listings.filter(listing => {
    let ok = true;

    if (filters.nearMe) {
      const dist = calculateDistance(listing.location, filters.userLocation);
      if (dist > filters.radiusMeters) ok = false;
    }

    if (filters.openNow) {
      const hour = new Date().getHours();
      if (!(listing.openingHour <= hour && hour <= listing.closingHour)) {
        ok = false;
      }
    }

    if (filters.category) {
      if (listing.category !== filters.category) ok = false;
    }

    return ok;
  });
}
----

Problems:
- Controller-level business logic.
- Repeated conditions in multiple files.
- Adding a new filter required editing several modules.
- Hard to test filtering rules independently.

==== After
Filters were refactored into **Specification objects**, each exposing a single, meaningful rule:

[source,typescript]
----
export interface Specification<T> {
  isSatisfiedBy(candidate: T): boolean;
}
----

Examples of concrete Specifications:

[source,typescript]
----
export class NearMeSpecification implements Specification<Listing> {
  constructor(private userLocation, private radiusMeters) {}

  isSatisfiedBy(listing: Listing): boolean {
    const dist = calculateDistance(listing.location, this.userLocation);
    return dist <= this.radiusMeters;
  }
}

export class OpenNowSpecification implements Specification<Listing> {
  constructor(private currentHour: number) {}

  isSatisfiedBy(listing: Listing): boolean {
    return listing.openingHour <= this.currentHour &&
      this.currentHour <= listing.closingHour;
  }
}
----

Specifications can be composed:

[source,typescript]
----
export class AndSpecification<T> implements Specification<T> {
  constructor(private left: Specification<T>, private right: Specification<T>) {}

  isSatisfiedBy(candidate: T) {
    return this.left.isSatisfiedBy(candidate) &&
           this.right.isSatisfiedBy(candidate);
  }
}
----

The call site becomes clean and intention-revealing:

[source,typescript]
----
const specs: Specification<Listing>[] = [];

if (filterVO.nearMe) specs.push(new NearMeSpecification(userLoc, filterVO.radius));
if (filterVO.openNow) specs.push(new OpenNowSpecification(currentHour));

const result = applySpecifications(allListings, specs);
----

Benefits:
- Encapsulated filtering rules.
- Easy to add new filters without modifying controllers.
- Clear mapping to the Filter VO.
- Fully testable and maintainable.


=== Strategy Pattern: Interchangeable Routing Providers

==== Before
Routing was tightly coupled to Leaflet's OSRMv1 provider. Controllers directly instantiated the OSRM router:

[source,typescript]
----
const router = L.Routing.osrmv1({
  serviceUrl: "https://router.project-osrm.org/route/v1",
});

router.route([origin, destination], callback);
----

Problems:
- Hard-coded provider (OSRMv1).
- No ability to switch to Google Maps, Mapbox, or custom routing.
- Difficult to test routing behavior.

==== After
A routing abstraction was introduced:

[source,typescript]
----
export interface RoutingStrategy {
  getRoute(origin: LatLng, destination: LatLng): Promise<RouteResult>;
}
----

Current implementation:

[source,typescript]
----
export class OSRMRoutingStrategy implements RoutingStrategy {
  private router = L.Routing.osrmv1({
    serviceUrl: "https://router.project-osrm.org/route/v1",
  });

  async getRoute(origin, destination) {
    return new Promise((resolve, reject) => {
      this.router.route([origin, destination], (err, routes) =>
        err ? reject(err) : resolve(routes[0])
      );
    });
  }
}
----

Planned strategies (documented but not implemented):

- GoogleMapsRoutingStrategy
- MapboxRoutingStrategy
- CustomShortestPathStrategy

Controller usage becomes:

[source,typescript]
----
const routingStrategy: RoutingStrategy = new OSRMRoutingStrategy();
const route = await routingStrategy.getRoute(origin, destination);
----

Benefits:
- Decouples controllers from routing provider.
- Enables future routing engines without refactoring.
- Clean, unified interface for route retrieval.
- Aligns with extensibility principles from Milestone 3.


=== Intention-Revealing Interfaces: Centralizing Authentication Logic

==== Before
Each page manually performed Supabase authentication and profile retrieval:

[source,typescript]
----
const { data: { user } } = await supabase.auth.getUser();
const { data: profile } = await supabase.from("profiles")
  .select("*")
  .eq("id", user.id)
  .single();
----

Problems:
- Code duplicated across pages.
- Mixed concerns (auth, profile lookup, redirects).
- Hard to maintain consistent profile structure.

==== After
The team introduced intention-revealing helpers:

[source,typescript]
----
export async function getAuthUserWithProfile(supabase) {
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) return { user: null, profile: null };

  const { data: profile } = await supabase
    .from("profiles")
    .select("*")
    .eq("id", user.id)
    .single();

  return { user, profile };
}
----

And a reactive hook:

[source,typescript]
----
export function useSupabaseAuth() {
  const supabase = useSupabase();
  const auth = ref({ user: null, loading: true });

  supabase.auth.onAuthStateChange((event, session) => {
    auth.value = {
      user: session?.user ?? null,
      loading: false,
    };
  });

  return auth;
}
----

Call sites become readable and meaningful:

[source,typescript]
----
const { user, profile } = await getAuthUserWithProfile(supabase);
if (!user) throw redirect(302, "/login");
----

Benefits:
- Eliminates repetition.
- Makes developer intent explicit.
- Consistent profile retrieval.
- Clear separation of concerns.

