=== *2.3.2 Application of Techniques*

This subsection presents the concrete techniques applied by the team during Milestone 3, demonstrating how the project evolved from scattered, duplicated logic to modular, intention-revealing, and maintainable structures. The examples below come from real improvements implemented by the Map, Auth, and Backend teams. Each example includes a before/after transformation aligned with Domain-Driven Design principles and the architectural rules described in <<_2_2_architecture_and_layering,Section 2.2 Architecture & Layering>>.

==== Specification Pattern: From Scattered Conditionals to Composable Rules

===== Before

Filtering logic in the Map and Listing domains was originally written using inline conditionals inside controllers, leading to duplication and tight coupling. Each filter—such as “Near Me,” “Open Now,” or “Category”—was evaluated manually:

[source,typescript]
----
function filterResults(listings, filters) {
  return listings.filter(listing => {
    let ok = true;

    if (filters.nearMe) {
      const dist = calculateDistance(listing.location, filters.userLocation);
      if (dist > filters.radiusMeters) ok = false;
    }

    if (filters.openNow) {
      const hour = new Date().getHours();
      if (!(listing.openingHour <= hour && hour <= listing.closingHour)) {
        ok = false;
      }
    }

    if (filters.category) {
      if (listing.category !== filters.category) ok = false;
    }

    return ok;
  });
}
----

Problems:

* Controller-level business logic.
* Repeated conditions in multiple files.
* Adding a new filter required editing several modules.
* Hard to test filtering rules independently.
* No clear mapping to the Filter Value Object documented in the domain model.

===== After

Filters were refactored into *Specification* objects, each exposing a single, meaningful rule through a shared interface:

[source,typescript]
----
export interface Specification<T> {
  isSatisfiedBy(candidate: T): boolean;
}
----

Examples of concrete Specifications:

[source,typescript]
----
export class NearMeSpecification implements Specification<Listing> {
  constructor(private userLocation, private radiusMeters: number) {}

  isSatisfiedBy(listing: Listing): boolean {
    const dist = calculateDistance(listing.location, this.userLocation);
    return dist <= this.radiusMeters;
  }
}

export class OpenNowSpecification implements Specification<Listing> {
  constructor(private currentHour: number) {}

  isSatisfiedBy(listing: Listing): boolean {
    return (
      listing.openingHour <= this.currentHour &&
      this.currentHour <= listing.closingHour
    );
  }
}
----

Specifications can be composed:

[source,typescript]
----
export class AndSpecification<T> implements Specification<T> {
  constructor(
    private left: Specification<T>,
    private right: Specification<T>
  ) {}

  isSatisfiedBy(candidate: T): boolean {
    return (
      this.left.isSatisfiedBy(candidate) &&
      this.right.isSatisfiedBy(candidate)
    );
  }
}
----

The call site becomes clean and intention-revealing:

[source,typescript]
----
const specs: Specification<Listing>[] = [];

if (filterVO.nearMe) {
  specs.push(new NearMeSpecification(userLoc, filterVO.radius));
}

if (filterVO.openNow) {
  specs.push(new OpenNowSpecification(currentHour));
}

const result = listings.filter(listing =>
  specs.every(spec => spec.isSatisfiedBy(listing))
);
----

*Benefits*:

* Encapsulated filtering rules instead of scattered conditionals.
* Easy to add new filters without modifying controllers.
* Clear mapping to the Filter VO.
* Fully testable, composable domain rules.


===== Strategy Pattern: Interchangeable Routing Providers

====== Before

Routing was tightly coupled to Leaflet’s OSRMv1 provider. Controllers directly instantiated and configured the OSRM router:

[source,typescript]
----
async function getRoute(origin, destination) {
  const router = L.Routing.osrmv1({
    serviceUrl: "https://router.project-osrm.org/route/v1",
  });

  return new Promise((resolve, reject) => {
    router.route([origin, destination], (err, routes) => {
      if (err) reject(err);
      else resolve(routes[0]);
    });
  });
}
----

Problems:

* Hard-coded provider (OSRMv1).
* No ability to switch to other routing engines (e.g., Google Maps, Mapbox, custom).
* Difficult to test routing behavior in isolation from Leaflet.
* Violated the Open–Closed Principle: adding a new routing policy required changing existing controller code.

===== After

A routing abstraction was introduced following the Strategy Pattern taught in lecture:

[source,typescript]
----
export interface RoutingStrategy {
  getRoute(origin: LatLng, destination: LatLng): Promise<RouteResult>;
}
----

Current concrete strategy:

[source,typescript]
----
export class OSRMRoutingStrategy implements RoutingStrategy {
  private router = L.Routing.osrmv1({
    serviceUrl: "https://router.project-osrm.org/route/v1",
  });

  async getRoute(origin: LatLng, destination: LatLng): Promise<RouteResult> {
    return new Promise((resolve, reject) => {
      this.router.route([origin, destination], (err, routes) => {
        if (err) reject(err);
        else resolve(routes[0]);
      });
    });
  }
}
----

Planned strategies (documented as extension points, not yet implemented):

* `GoogleMapsRoutingStrategy`
* `MapboxRoutingStrategy`
* `CustomShortestPathRoutingStrategy`

Controller usage becomes independent of the concrete routing engine:

[source,typescript]
----
const routingStrategy: RoutingStrategy = new OSRMRoutingStrategy();
const route = await routingStrategy.getRoute(origin, destination);
----

*Benefits*:

* Decouples controllers from a specific routing provider.
* Enables future routing engines by implementing the same interface.
* Simplifies testing by allowing mock strategies.
* Aligns with the Strategy Pattern as presented in the course and with the project’s extensibility goals.


==== Intention-Revealing Interfaces: Centralizing Authentication Logic

===== Before

Each protected page manually performed Supabase authentication and profile retrieval, mixing concerns and duplicating logic:

[source,typescript]
----
import { supabase } from "@/lib/supabaseClient";

export async function load({ redirect }) {
  const { data: { user }, error: userError } = await supabase.auth.getUser();
  if (!user || userError) {
    throw redirect(302, "/login");
  }

  const { data: profile, error: profileError } = await supabase
    .from("profiles")
    .select("*")
    .eq("id", user.id)
    .single();

  if (profileError) {
    throw redirect(302, "/login");
  }

  return { user, profile };
}
----

Problems:

* Authentication and profile logic duplicated in many routes.
* Slight variations in profile queries between pages.
* Harder to maintain consistent behavior when auth rules change.
* The main intention (“get authenticated user with profile or redirect”) was obscured by boilerplate.

===== After

The Auth team introduced intention-revealing helpers, matching the lecture’s emphasis on services with clear intent and side-effect-free functions where possible:

[source,typescript]
----
export async function getAuthUserWithProfile(supabase) {
  const { data: { user }, error: userError } = await supabase.auth.getUser();
  if (!user || userError) {
    return { user: null, profile: null };
  }

  const { data: profile, error: profileError } = await supabase
    .from("profiles")
    .select("*")
    .eq("id", user.id)
    .single();

  if (profileError) {
    return { user: null, profile: null };
  }

  return { user, profile };
}
----

At the call site, the logic becomes shorter and intention-revealing:

[source,typescript]
----
const { user, profile } = await getAuthUserWithProfile(supabase);
if (!user) {
  throw redirect(302, "/login");
}

return { user, profile };
----

For reactive components, a hook centralizes subscription to auth state:

[source,typescript]
----
export function useSupabaseAuth() {
  const supabase = useSupabase();
  const auth = ref({ user: null, loading: true });

  supabase.auth.onAuthStateChange((_event, session) => {
    auth.value = {
      user: session?.user ?? null,
      loading: false,
    };
  });

  return auth;
}
----

Typical usage:

[source,typescript]
----
const auth = useSupabaseAuth();

if (auth.value.loading) {
  return "Loading...";
}

if (!auth.value.user) {
  router.push("/login");
}
----

*Benefits*:

* **Intention-revealing**: the purpose of each helper is clear at the call site.
* **Centralized logic**: changes to authentication or profile retrieval occur in one place.
* **Consistency**: all pages rely on the same profile shape and redirect behavior.
* **Testability**: helpers can be tested separately from page code.
* **Alignment with lectures**: matches the emphasis on side-effect-free, intention-revealing services at boundaries.

===== Assertions and Domain Invariants

As discussed in the *Supple Design* lecture (slides 25–31), assertions help document and enforce the invariants that must always hold before and after domain operations. They make assumptions explicit, reduce ambiguity, and support the correctness of aggregates and services. In this project, assertions are incorporated into key operations across the Authentication, Backend, and Map subsystems to guarantee stability and prevent invalid states.

====== Authentication Operation: signUp(firstname, lastname, email, password)

The `signUp` flow creates a new user within the authentication subsystem. Assertions clarify the conditions under which the operation is valid and the guarantees it provides afterward.

*Preconditions*
- `email` is syntactically valid.
- `password` meets the security policy (≥ 8 characters, includes number or symbol).
- `email` is not already associated with an existing account.
- `firstname` and `lastname` are non-empty strings.

*Postconditions*
- A new User account exists with the provided email.
- The password is securely hashed (never stored in plain text).
- A valid session or authentication credential is created.
- The new user is considered authenticated immediately after sign-up.

This mirrors the lecture guidance that authentication workflows benefit from explicit pre- and post-conditions to avoid ambiguous states (e.g., “user created but not authenticated”).

====== Backend Operation: createPiece(pieceData)

The `createPiece` operation instantiates a new `Piece` entity and enforces domain rules regarding categories, conditions, and ownership.

*Preconditions*
- The seller initiating the operation is authenticated and valid.
- `category` must match one of the allowed domain categories.
- Provided attributes must be compatible with the category  
  (e.g., shoes must include `shoeSize`; accessories must not include a size field).
- `condition` ∈ {new, like-new, lightly-used, used, heavily-used}.
- `description` length does not exceed the domain’s maximum.

*Postconditions*
- A new Piece object exists and is associated with the seller.
- The Piece receives a unique `pieceID`.
- All fields (`category`, `condition`, `attributes`, `description`) match the validated input.
- The Piece enters the `unlisted` state and is not part of any Listing yet.

These assertions document the invariant that a Piece must always enter the system in a valid, unlisted, domain-compliant state.

====== Map Operation: nearMe(listings, userLocation)

The `nearMe` operation returns all listings within a fixed radius (8km) of the specified user location or map-selected point. Assertions ensure geospatial correctness and consistent results.

*Preconditions*
- `userLocation` contains valid latitude and longitude values.
- `listings` is a non-null, iterable collection.
- Each listing must include a valid meetup location or seller coordinate.

*Postconditions*
- Returned listings are only those within 8km of `userLocation`.
- No listing outside the radius appears in the result.
- Ordering of listings is preserved unless explicitly sorted afterward.
- The function has no side effects (does not modify listings or persist data).

By capturing the geospatial invariants explicitly, the Map subsystem aligns with the lecture principle that system behavior should never rely on hidden assumptions.

====== Summary

These assertions clarify the system’s behavioral expectations and match the lecture recommendations for maintaining model integrity through explicit invariants. Each subsystem—Auth, Backend, and Map—uses assertions to ensure operations transition between valid states, prevent malformed inputs, and reinforce domain rules. Together, they contribute to a more predictable, verifiable, and maintainable design.

===== Command–Query Separation (CQS) and Side-Effect-Free Validators

Command–Query Separation (CQS) was applied in the Auth subsystem to distinguish **pure, side-effect-free validation** from **mutating commands** that change authentication state or persist data. This refactor simplifies reasoning about behavior, improves testability, and aligns with the course emphasis on supple design.

====== Before: Mixed Validation and Side Effects in a Single Flow

Originally, several Auth-related flows combined **input validation**, **Supabase calls**, and **navigation/redirects** into a single function. A typical “sign up” handler both validated inputs and performed mutations:

[source,typescript]
----
export async function handleSignUp(formData, supabase, router) {
  const email = formData.get("email") as string;
  const password = formData.get("password") as string;
  const firstname = formData.get("firstname") as string;
  const lastname = formData.get("lastname") as string;

  // Inline validation
  if (!email || !email.includes("@")) {
    throw new Error("Invalid email.");
  }
  if (!password || password.length < 8) {
    throw new Error("Password too short.");
  }

  // Auth + profile creation (side effects)
  const { data, error } = await supabase.auth.signUp({
    email,
    password,
    options: {
      data: { firstname, lastname },
    },
  });

  if (error) {
    throw error;
  }

  router.push("/dashboard");
}
----

Problems:

* Queries (validation) and commands (mutations) were mixed together.
* The function had multiple responsibilities: validation, auth side effects, and navigation.
* Unit testing required mocking Supabase and routing even when only validation was under test.
* Intent was blurred: the *what* (validate vs. create) and the *how* (Supabase, router) were tangled.

====== After: Pure Validators + Explicit Command Handlers

The Auth Team refactored validation concerns into **pure functions** that take data and return validation results without side effects. Mutating logic was isolated in dedicated command handlers.

Pure validators (queries):

[source,typescript]
----
export function validateEmail(email: string): string[] {
  const errors: string[] = [];
  if (!email) {
    errors.push("Email is required.");
  } else if (!email.includes("@")) {
    errors.push("Email must contain '@'.");
  }
  return errors;
}

export function validatePassword(password: string): string[] {
  const errors: string[] = [];
  if (!password || password.length < 8) {
    errors.push("Password must be at least 8 characters.");
  }
  if (!/\d|\W/.test(password)) {
    errors.push("Password must include a number or symbol.");
  }
  return errors;
}

export function validateProfileFields(firstname: string, lastname: string): string[] {
  const errors: string[] = [];
  if (!firstname.trim()) {
    errors.push("First name is required.");
  }
  if (!lastname.trim()) {
    errors.push("Last name is required.");
  }
  return errors;
}
----

These functions:

* Have **no side effects** (no Supabase calls, no router calls).
* Always return the same output for the same input.
* Are easy to unit-test in isolation.

Command handler (mutation):

[source,typescript]
----
export async function handleCreateAccount(formData, supabase, router) {
  const email = formData.get("email") as string;
  const password = formData.get("password") as string;
  const firstname = formData.get("firstname") as string;
  const lastname = formData.get("lastname") as string;

  const errors = [
    ...validateEmail(email),
    ...validatePassword(password),
    ...validateProfileFields(firstname, lastname),
  ];

  if (errors.length > 0) {
    return { ok: false, errors };
  }

  const { data, error } = await supabase.auth.signUp({
    email,
    password,
    options: {
      data: { firstname, lastname },
    },
  });

  if (error) {
    return { ok: false, errors: [error.message] };
  }

  router.push("/dashboard");
  return { ok: true, errors: [] };
}
----

Here:

* The **command** (`handleCreateAccount`) is clearly responsible for *doing things*:
  * calling Supabase (auth side effect),
  * triggering navigation.
* All **query-style logic** (validation) is delegated to pure functions.
* The handler’s return structure (`{ ok, errors }`) makes behavior explicit and testable.

====== Benefits of the CQS Refactor

* **Clear Separation of Responsibilities**  
  Validators answer questions (“Is this input valid?”) without changing state, while commands modify state or trigger navigation.

* **Improved Testability**  
  Pure validators can be tested without mocking Supabase or routing. Command handlers can be tested with targeted integration or mocking.

* **Reduced Side Effects**  
  Fewer functions can unexpectedly cause persistence or navigation; side effects are localized to command functions.

* **Easier Reasoning and Maintenance**  
  Developers can quickly see where mutations happen and reuse validators across multiple forms or flows.

* **Alignment with Course Guidance**  
  The refactor demonstrates Command–Query Separation by drawing a firm line between “asking” (validators) and “doing” (commands), while keeping domain rules explicit and intention-revealing.

====== Additional CQS Example: signIn (Command) vs getUser (Query)

The Auth subsystem also illustrates Command–Query Separation through a clear distinction between *commands* that change authentication state and *queries* that only read it. Here we document the evolution of the login flow from a mixed command/query function into a clean split between `signIn` (command) and `getUser` (query).

======= Before: Login Flow Mixing Command and Query Responsibilities

Initially, a single function handled both:

* reading current authentication state
* performing a login attempt (mutation)
* deciding navigation behavior

[source,typescript]
----
export async function handleSignIn(formData, supabase, router) {
  const email = formData.get("email") as string;
  const password = formData.get("password") as string;

  const { data: { user: existingUser } } = await supabase.auth.getUser();
  if (existingUser) {
    router.push("/dashboard");
    return;
  }

  const { data, error } = await supabase.auth.signInWithPassword({
    email,
    password,
  });

  if (error) {
    throw new Error(error.message);
  }

  router.push("/dashboard");
}
----

Problems:

* **Mixed responsibilities**: querying current user and performing sign-in in the same function.
* **Harder to reuse**: any flow that only needed current user information still depended on login logic.
* **More complex tests**: tests had to mock both the query (`getUser`) and the command (`signInWithPassword`) for this one function.
* **Weaker intent**: it was not obvious from the API which parts *read* state and which parts *mutated* it.

======= After: Explicit Query (`getAuthUser`) and Command (`signInCommand`)

The logic was refactored into:

* a **query** function `getAuthUser` that only reads current authentication state
* a **command** function `signInCommand` that performs sign-in and produces side effects

Query (no side effects):

[source,typescript]
----
export async function getAuthUser(supabase) {
  const { data: { user }, error } = await supabase.auth.getUser();

  if (error) {
    return { user: null, error };
  }

  return { user, error: null };
}
----

Command (mutation + navigation):

[source,typescript]
----
export async function signInCommand(
  email: string,
  password: string,
  supabase,
  router
) {
  const { data, error } = await supabase.auth.signInWithPassword({
    email,
    password,
  });

  if (error) {
    return { ok: false, error: error.message };
  }

  router.push("/dashboard");
  return { ok: true, error: null };
}
----

The form handler then uses the query and command explicitly:

[source,typescript]
----
export async function handleSignIn(formData, supabase, router) {
  const email = formData.get("email") as string;
  const password = formData.get("password") as string;

  const { user } = await getAuthUser(supabase);
  if (user) {
    router.push("/dashboard");
    return;
  }

  const result = await signInCommand(email, password, supabase, router);
  if (!result.ok) {
    throw new Error(result.error ?? "Unable to sign in.");
  }
}
----

Benefits of this CQS refactor:

* **Explicit intent**: `getAuthUser` clearly communicates that it only *reads* the current user, while `signInCommand` clearly *acts* to change authentication state.
* **Improved reuse**: `getAuthUser` can be reused anywhere current user information is needed without pulling in sign-in logic.
* **Easier testing**: query and command logic can be unit-tested independently with focused mocks.
* **Consistent CQS story**: together with the side-effect-free validators and command handlers documented earlier, this example strengthens the project’s adherence to Command–Query Separation in the Auth subsystem.

===== Stand-Alone Auth Provider: Centralizing Supabase SDK Dependency

To reduce coupling and follow the “stand-alone class” guidance from the Supple Design lecture, the Auth Team refactored how components access authentication. Instead of each component depending directly on the Supabase Auth SDK, all SDK usage is now centralized in a stand-alone provider (`SupabaseAuthProvider`) and a stable hook (`useSupabaseAuth`). This section documents the before/after transformation and how it reduces dependencies.

====== Before: Components Depending Directly on Supabase Auth SDK

Originally, multiple components imported and used the Supabase client directly. Each component was responsible for calling the SDK, handling session changes, and interpreting authentication state.

Example (simplified):

[source,typescript]
----
import { supabase } from "@/lib/supabaseClient";
import { onMounted, ref } from "vue";

export default {
  setup() {
    const user = ref(null);
    const loading = ref(true);

    onMounted(async () => {
      const { data: { user: currentUser } } = await supabase.auth.getUser();
      user.value = currentUser ?? null;
      loading.value = false;

      supabase.auth.onAuthStateChange((_event, session) => {
        user.value = session?.user ?? null;
      });
    });

    async function handleSignOut() {
      await supabase.auth.signOut(); 
      user.value = null;
    }

    return { user, loading, handleSignOut };
  },
};
----

Problems:

* Each component depended directly on the Supabase Auth SDK.
* Auth state subscription logic was duplicated across components.
* Changing auth provider (or how sessions are handled) required editing many files.
* Testing components required mocking the Supabase client in multiple places.
* The intent (“I need auth state”) was obscured by low-level SDK calls.

====== After: SupabaseAuthProvider and useSupabaseAuth as Stand-Alone Abstractions

The team introduced a stand-alone provider component and a shared hook to encapsulate SDK calls. Components no longer depend on the Supabase SDK; instead, they depend only on a stable interface defined by `useSupabaseAuth`.

Provider component (stand-alone class/component):

[source,typescript]
----
import { supabase } from "@/lib/supabaseClient";
import { defineComponent, provide, ref, onMounted } from "vue";

const AuthSymbol = Symbol("AuthContext");

export const SupabaseAuthProvider = defineComponent({
  name: "SupabaseAuthProvider",
  setup(_, { slots }) {
    const user = ref(null);
    const loading = ref(true);

    onMounted(async () => {
      const { data: { user: currentUser } } = await supabase.auth.getUser();
      user.value = currentUser ?? null;
      loading.value = false;

      supabase.auth.onAuthStateChange((_event, session) => {
        user.value = session?.user ?? null;
      });
    });

    async function signOut() {
      await supabase.auth.signOut();
      user.value = null;
    }

    const value = { user, loading, signOut };

    provide(AuthSymbol, value);

    return () => slots.default ? slots.default() : null;
  },
});

export function useSupabaseAuth() {
  const ctx = inject(AuthSymbol);
  if (!ctx) {
    throw new Error("useSupabaseAuth must be used within SupabaseAuthProvider.");
  }
  return ctx;
}
----

Component usage after refactor:

[source,typescript]
----
import { useSupabaseAuth } from "@/auth/SupabaseAuthProvider";

export default {
  setup() {
    const { user, loading, signOut } = useSupabaseAuth();

    return {
      user,
      loading,
      handleSignOut: signOut,
    };
  },
};
----

Key changes:

* All Supabase Auth SDK calls (getUser, onAuthStateChange, signOut) are centralized in `SupabaseAuthProvider`.
* Components depend only on the stable stand-alone abstraction `useSupabaseAuth`.
* If the project changes auth providers or session handling, only the provider implementation must be updated.

====== Diagram: Stand-Alone Auth Provider Reducing Dependencies

[plantuml]
----
@startuml
interface AuthInterface {
  +user
  +loading
  +signOut()
}

class SupabaseAuthProvider {
  -supabaseClient
  +provide(AuthInterface)
}

class ComponentA
class ComponentB

SupabaseAuthProvider ..> AuthInterface
ComponentA --> AuthInterface : uses via useSupabaseAuth()
ComponentB --> AuthInterface : uses via useSupabaseAuth()

AuthInterface <|.. SupabaseAuthProvider
@enduml
----

====== Dependency Reduction and Benefits

* **Reduced Dependencies:**  
  Components no longer import or configure the Supabase client directly; they depend only on `useSupabaseAuth`, a stand-alone abstraction.

* **Centralized SDK Usage:**  
  All low-level SDK calls are located in a single provider file, making changes to the auth backend or session behavior localized.

* **Improved Testability:**  
  Components can be tested by mocking `useSupabaseAuth` instead of mocking the entire Supabase client. This yields simpler, more targeted tests.

* **Clearer Intent:**  
  At the component level, the code now expresses intent (“I need auth state and signOut”) rather than implementation details (“call supabase.auth.getUser() and manage listeners”).

* **Alignment with Milestone 3 and Lectures:**  
  The `SupabaseAuthProvider` behaves as a stand-alone class that shields the rest of the system from low-level dependencies, satisfying the Milestone 3 requirement for dependency reduction and reflecting the stand-alone class guidance from the Supple Design lecture.
