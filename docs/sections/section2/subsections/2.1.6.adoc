=== *2.1.6 - Function Signatures*

==== Objective
Define domain-level function signatures that describe how actions are carried out, including inputs,
outputs, and possible changes in the domain.

==== Description

Function signatures specify how actors in the system interact through domain actions. They define the logical relationships between inputs, outputs, and resulting state changes: 

- *The name of the function*: The action being performed.  
- *The input parameters*: The information required by the action.  
- *Output*: Type of data the function produces.  
- *State changes*: How the action affects the domain.

The general format of a function signature is:

- FunctionName: Input1 >< Input2 >< ... -> OutputType
- **Description** – what the function does.
- **Preconditions** – what must be true or available for the function to execute.
- **Postconditions** - what becomes true afterwards.
- **Notes** - clarifications about scope, limits, or non-covered cases.

==== Examples

publishListing : Piece >< Seller >< Locale -> Either[ValidationError,ListingPublished]

Description:: A Seller publishes a Piece in a given Locale, producing a ListingPublished event.

Preconditions:: Seller and Piece exist and are active; Piece has required metadata (title, condition, images).

Postconditions:: Listing becomes visible; `ListingPublished` recorded.

Notes:: Discovery-only; no in-platform payments.


expressInterest : Listing >< Buyer -> Either[ContactError, InterestExpressed]

Description:: A Buyer signals interest in a Listing to start contact with the Seller.

Preconditions:: Listing is open; Buyer is authenticated.

Postconditions:: `InterestExpressed` links Buyer and Seller.

Notes:: Returns `ContactError` if listing is closed/unavailable.

rate : Piece >< ConditionRating -> Option[ConditionRating]

Description:: Assigns or updates a Piece’s condition rating.

Preconditions:: Piece exists; rating within 1–5.

Postconditions:: Piece’s stored rating updated.

Notes:: Returns `None` if Piece missing/inactive.

review : Seller >< Buyer >< Review -> Either[ReviewError, ReviewSubmitted]  

Description:: Records a review after an offline exchange.

Preconditions:: A prior interaction/closed listing exists between the parties.


Postconditions:: `ReviewSubmitted` attached to reviewer/reviewee.
Notes:: Returns `ReviewError` if no eligible exchange is found.

closeListing : Listing >< Seller -> Either[ClosedError, ListingClosed]  

Description:: Seller closes an active Listing after exchange or withdrawal.

Preconditions:: Seller owns the Listing; Listing is active.

Postconditions:: Listing state becomes "closed"; 'ListingClosed' recorded.

Notes:: Not callable by Buyers.

categorize : Piece >< Type -> Option[Piece]

Description:: Assigns a category type to a Piece.

Preconditions:: Piece exists; Type is valid.

Postconditions:: Piece’s Type attribute updated.

Notes:: Returns `None` if Piece missing/inactive. Does not change visibility.

discard : Piece -> Option[Void]

Description:: Removes a Piece from active circulation.

Preconditions:: Piece exists and is active.

Postconditions:: Piece marked as discarded/inactive.

Notes:: Returns `None` if Piece missing/inactive.

==== Example Scenario: From Listing to Offline Exchange
1. Seller publishes a listing using `publishListing(Piece, Seller, Locale)` → produces `ListingPublished`.  
2. Buyer browses available items and finds one of interest.  
3. Buyer triggers `expressInterest(Listing, Buyer)` → produces `InterestExpressed`.  
4. Both users coordinate offline to exchange the item.  
5. Seller closes the listing via `closeListing(Listing, Seller)` → produces `ListingClosed`.  
6. Buyer leaves a review using `review(Seller, Buyer, Review)` → produces `ReviewSubmitted`.
