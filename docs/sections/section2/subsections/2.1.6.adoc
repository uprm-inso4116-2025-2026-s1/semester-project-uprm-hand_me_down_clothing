=== *2.1.6 - Function Signatures*

==== Objective
Define domain-level function signatures that describe how actions are carried out, including inputs,
outputs, and possible changes in the domain. These signatures reflect the separation between
entities, events, and repositories as clarified in professor feedback.

==== Description

Function signatures specify how actors in the system interact through domain actions.  
They define the logical relationships between inputs, outputs, and resulting state changes:

- *The name of the function*: The action being performed.  
- *The input parameters*: The information and collaborators required by the action.  
- *Output*: The type of data or event the function produces.  
- *State changes*: How the action affects the domain (typically via repositories).

The general format of a function signature is:

- `FunctionName : Input1 >< Input2 >< ... -> OutputType`
- **Description** – what the function does.
- **Preconditions** – what must be true or available for the function to execute.
- **Postconditions** – what becomes true afterwards.
- **Notes** – clarifications about scope, limits, or non-covered cases.

In addition to individual entities (Piece, Listing, Seller, Buyer), we use the following domain-level collaborators:

- `ListingRepository` as the *domain-level collection* that conceptually stores all listings in the system.  
  From this repository we can derive:
  - *all listings* (including closed/archived),
  - *available listings* (listings that are still open and visible to buyers).

- `InterestRepository` as the *domain-level collection* that stores **Interest** entities.  
  An **Interest** connects a Buyer and a Listing and is distinct from the **InterestExpressed** event.

- `ListingFactory` as the domain-level service responsible for constructing Listing instances from input
  data (Piece, Seller, Locale, and related metadata) before they are persisted by the ListingRepository.

Browsing and searching operations always work **against** `ListingRepository`.  
Contact/interest operations work **against** `InterestRepository`.

==== Filter Value Object

A **Filter** is a *value object* that represents buyer-defined search constraints.  
It is immutable and does not depend on `Piece`, `Page`, or UI-layer concepts.

The Filter has the following fields:

[cols="1,3,2",options="header"]
|===
| Field
| Description
| Type / Concept

| `category`
| Desired category of the item. Optional.
| Value: ++Category++

| `size`
| Requested size. Optional.
| Value: ++Size++

| `gender`
| Intended gender classification. Optional.
| Value: ++Gender++

| `minCondition`
| Minimal acceptable condition rating. Optional.
| Value: ++ConditionRating++

| `maxPrice`
| Maximum price the buyer is willing to pay. Optional.
| Value: Money

| `locale`
| Campus/location where the buyer is willing to meet. Optional.
| Value: ++Locale++

| `textQuery`
| Free-text query for title/description matches. Optional.
| Value: String

| `onlyActive`
| Whether to restrict results to active listings. Defaults to true.
| Boolean
|===

The Filter induces a matching predicate:

`matches(f: Filter, p: Listing)` holds iff all present fields in `f` are satisfied by `p`.

This value object is used explicitly by the search-related function signatures below.

==== Function Signatures

publishListing : Piece >< Seller >< Locale >< ListingRepository -> Either[ValidationError, Listing]

Description::  
A Seller publishes a Piece in a given Locale, producing and persisting a new Listing.

Preconditions::  
Seller and Piece exist and are active; Piece has required metadata (title, condition, images).

Postconditions::  
A ListingFactory constructs a new Listing from the Piece, Seller, and Locale.  
The new Listing is stored in the ListingRepository as *available* and the same Listing is returned as part of the result.

Notes::  
Discovery-only; no in-platform payments.  
Validation errors (e.g., missing images, invalid locale) are represented as ValidationError on the left side of the Either.

expressInterest : Listing >< Buyer >< InterestRepository -> Either[ContactError, InterestExpressed]

Description::  
A Buyer signals interest in a Listing, creating a new **Interest** entity that references the Buyer and the Listing.  
The **InterestExpressed** event records the moment this Interest is created.

Preconditions::  
Listing is available (open); Buyer is authenticated.

Postconditions::  
A new Interest entity is created and stored in the InterestRepository, referencing the Buyer and the Listing.  
An InterestExpressed event is emitted/returned to reflect that this Interest has just been created.

Notes::  
This function uses the InterestRepository to persist the Interest (entity) and the event to record the occurrence in the domain timeline.

rate : Piece >< ConditionRating -> Piece

Description::  
Assigns or updates a Piece’s condition rating.

Preconditions::  
Piece exists; rating is within the valid scale.

Postconditions::  
Returns the updated Piece with the new ConditionRating embedded within it.

review : Seller >< Buyer >< Review -> Either[ReviewError, ReviewSubmitted]

Description::  
Records a review after an offline exchange.

Preconditions::  
A prior successful exchange exists between the parties.

Postconditions::  
ReviewSubmitted maintains references to the Listing and the User being reviewed.  
Listings do not store or contain Reviews structurally; reviews are associated via references.

closeListing : Listing >< Seller -> Either[ClosedError, Listing]

Description::  
Seller closes an active Listing after an exchange or withdrawal.

Preconditions::  
Seller owns the Listing; Listing is active.

Postconditions::  
Listing state becomes terminal (sold/donated/retracted) and the updated Listing is returned.  
The updated Listing can then be persisted via the ListingRepository.

categorize : Piece >< Type -> Option[Piece]

Description::  
Assigns a category type to a Piece; returns an updated Piece if the categorization is applicable.

discard : Piece -> Option[Void]

Description::  
Marks a Piece as inactive and removes it from circulation.

browseAvailableItems : ListingRepository -> Set<Listing>

Description::  
Returns the set of Listings that are currently *available*.

Preconditions::  
ListingRepository is defined.

Postconditions::  
Returns a (possibly empty) set of available Listings.

Notes::  
Backend operates solely on active listings for this operation.

findAvailableByFilter : ListingRepository >< Filter -> Set<Listing>

Description::  
Returns the set of available Listings that satisfy the Filter predicate.

Preconditions::  
ListingRepository is defined; Filter is valid.

Postconditions::  
Returns all Listings that are:
* available, and  
* matching the Filter (according to `matches(f, p)`).

Notes::  
Distinguishes “all listings” from the subset that is currently available and relevant to buyers.

findListingById : ListingRepository >< ListingID -> Option[List‌ing]

Description::  
Retrieves a Listing by identifier from the ListingRepository.

==== Example Scenario: From Listing to Offline Exchange

1. Seller publishes a listing using  
   `publishListing(Piece, Seller, Locale, ListingRepository) -> Either[ValidationError, Listing]`,  
   and, on success, the new Listing is constructed by ListingFactory, stored in the ListingRepository as *available*, and returned.

2. Buyer browses available items using  
   `browseAvailableItems(ListingRepository) -> Set<Listing>`  
   or refines results using  
   `findAvailableByFilter(ListingRepository, Filter) -> Set<Listing>`.

3. Buyer expresses interest using  
   `expressInterest(Listing, Buyer, InterestRepository) -> Either[ContactError, InterestExpressed]`,  
   which both persists a new Interest in the InterestRepository and emits the InterestExpressed event.

4. The exchange happens offline.

5. Seller closes the listing using  
   `closeListing(Listing, Seller) -> Either[ClosedError, Listing]`,  
   and the returned Listing reflects the new terminal state (sold/donated/retracted).

6. Buyer leaves a review using  
   `review(Seller, Buyer, Review) -> Either[ReviewError, ReviewSubmitted]`,  
   which records a review referencing the counterpart and the related Listing without embedding the review into the Listing structure.
