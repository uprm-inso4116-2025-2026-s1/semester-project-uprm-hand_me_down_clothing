// --
// Author: Kevin Gomez
// Institution: University of Puerto Rico at Mayagüez
// Date Created: 2025-10-21
// Version: 1.0
// Project: Hand-me-down Clothing
// Purpose: Documentation for the factory layer — specifically, the PieceFactory class responsible for creating Piece domain objects and transforming them into DTOs.
// --

# Factory Layer Documentation

## Overview

The factory layer is designed to handle the creation and transformation of domain entities. In this project, it ensures consistent logic when generating objects such as `SoldPiece` or `DonatedPiece` from raw database records and vice versa.

Factories centralize instantiation logic, allowing the system to:
- **Maintain consistency** when constructing domain objects.
- **Encapsulate creation rules**, reducing duplication across the codebase.
- **Isolate transformation logic** between the data and domain layers.

---

## Piece Factory -> PieceFactory

### Purpose
The `PieceFactory` class is responsible for constructing `Piece` domain objects from raw database records and converting `Piece` instances back into plain objects suitable for database operations. It automatically determines whether a record should be treated as a `SoldPiece` or `DonatedPiece` based on its attributes (specifically, the presence of a `price`).

### Responsibilities
- Generate `SoldPiece` or `DonatedPiece` instances dynamically.
- Provide a unified interface to handle both donation and sale pieces.
- Transform `Piece` objects into data transfer objects (DTOs) for insertion or updating in Supabase.
- Enforce consistent construction rules across the data and domain layers.

### Benefits
- **Abstraction:** The logic for differentiating between `SoldPiece` and `DonatedPiece` is centralized.
- **Consistency:** Guarantees that every `Piece` object is created with valid, structured data.
- **Maintainability:** Simplifies the process of adding new subtypes (e.g., `RentedPiece`) in the future.
- **Reusability:** Both repositories and services can use the same factory without duplicating object creation logic.
- **Error Reduction:** Minimizes incorrect instantiation of objects by ensuring domain integrity.

---

## Methods Summary

[cols="1,1,2,1", options="header"]
|===
| Method | Return Type | Description | Example
|makePiece(item) | Piece | Creates a `SoldPiece` or `DonatedPiece` based on the provided record | `factory.makePiece(dbRecord)`
|toDTO(piece) | Record&lt;string, any&gt; | Converts a `Piece` domain object into a DTO for database storage | `factory.toDTO(piece)`
|===

---

## Justification for Factory Pattern

The factory pattern is used to encapsulate complex object creation logic and promote a clean separation between raw data and domain entities. By centralizing construction, the application gains:
- **Simplified creation:** Avoids scattered `new` calls throughout the code.
- **Reduced coupling:** Domain logic doesn’t depend on how objects are instantiated.
- **Better testability:** Creation rules can be tested independently from repositories.
- **Consistency across layers:** Ensures that domain models always follow the same initialization logic, regardless of source.

---

## Example Usage

```ts
const factory = new PieceFactory();

// Convert a database record into a domain object
const piece = factory.makePiece({
  id: "1",
  name: "Blue Shirt",
  category: "SHIRT",
  price: 20,
  condition: "LIKE_NEW",
  images: [],
  user_id: "user123"
});
console.log(piece instanceof SoldPiece); // true

// Convert a domain object back to a DTO for saving
const dto = factory.toDTO(piece);
console.log(dto);
```
// --
// Author: Jorge L. De León Orama
// Institution: University of Puerto Rico at Mayagüez
// Date Created: 2025-11-13
// Version: 1.0
// Project: Hand-me-down Clothing
// Purpose: Documentation for the factory layer. Specifically, the LocationFactory class responsible for creating Location domain objects and transforming them into Persistence Structure and viceversa.
// -- 

## Location Factory -> LocationFactory

### Purpose 
The `LocationFactory` class enforces the `Location` 's *aggregate invariants* by by envoking the value objects construction which provide all the required fields, rules, and validations for each identified *invariant* , effectively hidding the construction complexity and effectively seperating creation logic from behavior logic. This class will be dedicated to rebuilding `Location` attributes obtained from persistence (*Supabase*). 

### Responsibilities
- Construct the `Location` aggregate using only valid data, enforcing all domain invariants, and preventing construction of invalid aggregates.
- Reconstitute a `Location` from persistence (*Supabase*), converting raw persistence data (*Value Objects*), rebuilding the full aggreagate without bypassing invariants, and translating persistence format -> domain format.=, and vice versa.
- Provide a single construction point, the factory is the only place where the construction logic lives.
- Guarantee layer isolation, the factory never talks to Supabase directly, its only job is transforming data -> domain & domain -> data.

### Benefits
- **Ensures Aggregate Integrity:** Centralizes contruction logic, guaranteeing that no invalid `Location` object can ever be created, enforcing all `Location` invariants consistently.
- **Prevents bypassing of Domain Rules:** When reconstituting objects from persistence, the factory ensures that the database data cannot bypass validation, keeping the domain model safe from corrupted, duplications, or incomplete records.
- **Safe loading from the database:** When reading from persistence, the factory converts that raw data into a proper `Location`. 
- **Easier to change:** If the creation rules change, we only update the factory. This makes the code easier to maintain.

## Methods Summary

[options= "header", cols="^,^,^,^"]

|===
|Method | Return Type | Description | Example
|toDomainFormat(rawLocation) | Location | Creates a `Location` instance based on the provided persistence formatted location. rawLocation -> domainLocation| toDomainFormat(store)
|toPersistenceFormat(domainFormattedLocation) |PersistenceLocation | Flattens a `Location` instance based on the provided domain formatted location. domainLocation -> rawLocation|toDomainFormat(rawLocation)
|===

## Justification for Factory Pattern
This Factory Pattern is used because the `Location` aggregate requires strict, consistent and validated construciton, which cannot be guaranteed if objectsa re instantiated freely throughout the system. By centralizing all creation inside the LocationFactory, we ensure:
- **Invariant Enforcement:** is created only through value objects, ensuring all rules, constraints and validations are always applied, preventing invalid aggreagtes from entering the domain.
- **Safe Reconstitution From Persistence:** When loading data from Superbase, the factory reconstructs a fully valid `Location` rather than allowing persistence records to bypass domain rules. This protects the domain model from incorrectly formed, incomplete, or corrupted data.
- **Single Point of Change:** If cretion rules change (new invariants, new fields, new validations), only rhe factory needs updating. This reduces duplication and improves maintanabilty accross the system.
- **Proper Layer Isolation:** The factory transforms raw persistence structures to domain objects, and domain objects to persistence structures without ever interacting with the Supabase directly, perserving a clean architecture boundaries. 

## Example Usage

```ts
const LocationFactory= new LocationFactory();

async fetchAllLocations() : Promise<Location[]>{
        const {data, error} = await this.supabase.from("stores").select("*");
        if(error){
            throw new Error(`Could not fetch locations: ${error.message}`);
        }
        if(!data){
            throw new Error("Could not fetch all locations, data not found.");
        }

        //Transforms rawLocation data (store) into a domain object.
        const locationRecord: Location[]= data.map(store => LocationFactory.toDomainFormat(store) );
        return locationRecord;
    }
```