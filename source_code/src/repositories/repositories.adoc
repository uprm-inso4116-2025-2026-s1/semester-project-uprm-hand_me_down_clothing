// --
// Author: Kevin Gomez
// Institution: University of Puerto Rico at Mayagüez
// Date Created: 2025-10-21
// Version: 1.0
// Project: Hand-me-down Clothing
// Purpose: Documentation for repository layer — specifically, the PieceRepository class responsible for handling CRUD and filtering operations for clothing pieces.
// --

# Repository Layer Documentation

## Overview

The repository layer acts as an abstraction between the application's domain logic and its data sources (in this case, Supabase). It provides a consistent API for the rest of the system to interact with data without depending directly on database queries or client configurations.

By using repositories, the system achieves:
- **Separation of concerns** between business logic and data persistence.
- **Easier testing** via mocking repository interfaces.
- **Simplified maintainability** when changing data sources (e.g., migrating from Supabase to another backend).
- **Improved readability** and a centralized place for handling data-related logic.

---

## Piece Repository -> PieceRepository

### Purpose
Handles all CRUD (Create, Read, Update, Delete) and filtering operations related to the `Piece` domain object. It also transforms database records into domain entities through the `PieceFactory`.

### Responsibilities
- Fetch all clothing pieces or a specific piece by ID.
- Create, update, and delete clothing piece entries.
- Filter pieces based on multiple attributes such as name, category, color, size, brand, gender, price, and condition.
- Use the `PieceFactory` to convert between database DTOs and domain entities (ensuring consistent business logic).

### Benefits
- **Abstraction:** The rest of the application doesn’t need to know about the database structure or queries.
- **Reusability:** Common data operations are encapsulated, reducing code duplication.
- **Consistency:** Data is retrieved and transformed through a single, standardized interface.
- **Error Handling:** Centralized error catching and null safety mechanisms prevent propagation of invalid data.
- **Scalability:** Makes it easy to integrate caching or switch databases later without refactoring domain or UI layers.

---

## Methods Summary

[cols="1,1,2,1", options="header"]
|===
| Method | Return Type | Description | Example
|getPieces() | Promise&lt;Array&lt;Piece&gt;&gt; | Retrieves all pieces from the database | `repo.getPieces()`
|getPieceById(id) | Promise&lt;Piece \| null&gt; | Fetches a single piece by its unique ID | `repo.getPieceById("12")`
|createPiece(piece) | Promise&lt;Error \| null&gt; | Inserts a new piece record | `repo.createPiece(newPiece)`
|updatePiece(piece) | Promise&lt;boolean&gt; | Updates an existing record | `repo.updatePiece(existingPiece)`
|deletePiece(id) | Promise&lt;boolean&gt; | Deletes a record by ID | `repo.deletePiece("12")`
|filterPieces(filters) | Promise&lt;Array&lt;Piece&gt;&gt; | Retrieves pieces based on provided criteria | `repo.filterPieces({ color: "red", size: "M" })`
|===

---

## Justification for Repository Pattern

The repository pattern is used to decouple the domain and data mapping layers, ensuring that the domain model remains free from data-access logic. This allows for:
- **Cleaner architecture:** Reduces direct dependencies on Supabase queries or API responses.
- **Easier unit testing:** Repositories can be mocked or stubbed.
- **Enhanced flexibility:** Future migration to other databases (e.g., PostgreSQL, Firebase) can be done without altering core business logic.
- **Better maintainability:** Centralizing data operations minimizes redundancy and potential inconsistencies across services.

---

## Example Usage

```ts
const repo = new PieceRepository();

// Create a new piece
await repo.createPiece({
  name: "Summer T-shirt",
  category: "SHIRT",
  color: "red",
  brand: "H&M",
  gender: "UNISEX",
  size: "MEDIUM",
  price: 10,
  condition: "LIKE_NEW",
  reason: "Style change",
  images: ["tshirt1.png"],
  user_id: "847"
});

// Retrieve filtered pieces
const filtered = await repo.filterPieces({ category: "SHIRT", color: "red" });
console.log(filtered.length);
```

// --
// Author: Jorge L De León Orama
// Institution: University of Puerto Rico at Mayagüez
// Date Created: 2025-11-16
// Version: 1.0
// Project: Hand-me-down Clothing
// Purpose: Documentation for repository layer. Specifically, the LocationRepository class responsible for handling CRUD and filtering operations for Locations (Stores).
// --

## Location Repository -> LocationRepository

### Purpose 
Handles Create, Read, Update, Delete and filtering operations related to the Location domain object. It also handles database  to domain and domain to database data type formatting via the `LocationFactory`.

### Responsibilities
- Fetch all Locations from Supabase, converting each persistence record into a `Location` aggregate via `LocationFactory`, and returning them as `Location[]`.
- Fetch a single location by ID, querying Supabase by primary key, validating that exactly one row is returned, and mapping it to a `Location` aggregate.
- Create a new location, convering a `Location` aggregate into a persistence-friendly `PersistenceLocation` and inserting it into the `stores` table.
- Update an existing location, flattening a `Location` aggregate to `PersistenceLocation`, updating the matching row in Supabase by `id`, and ensuring the row exists.
- Delete a location, converting the `Location` aggregate to its persistence form and deleting the corresponding row in Supabase by `id`.
- Delegate all domain <-> persistence transfomations to `LocationFactory`, ensuring that the repository never constructs or validates `Location` directly.
- Isolate persistence concerns, encapsulating all Supabase calls so that the rest of the application interacts only with the `LocationRepository` and domain `Location` objects.

### Benefits
- **Centralizes all Persistence Logic:** Keeps Supabase queries in one place and pervents database code from leaking into the domain layer.
- **Ensures Consistent Data Validation:** Always converts records through the `LocationFactory`, preserving all aggreagte invariants.
- **Improves Maintainability:** Changes to the database strucutre or querying logic only require updates in the repository layer.
- **Guarantees Clean Architecture Boundaries:** Allows the rest of the system to work exclusively with domain `Location` objects instead of raw JSON.
- **Simplifies Application Code:** Offers high-level CRUD operations without exposing low-level Supabase details.
- **Reduces Duplication:** All database interactions and formatting steps are encapsulates in single, reusable methods. 

---

## Methods Summary
[cols="1,1,2,1", options="header"]
|===
| Method | Return Type | Description | Example
|getAllLocations() | Promise&lt;Array&lt;Location&gt;&gt; | Retrieves all locations from the database and maps them into domain objects | `repo.fetchAllLocations()`
|getLocationById(id) | Promise&lt;Location&gt; | Fetches a single location by its unique ID, validating that only one result exists. | `repo.fetchLocationByID(101)`
|createLocation(location) | Promise&lt;void&gt; | Inserts a new Location into the database after flattening it into persistence format | `repo.createLocation(newLocation)`
|updateLocation(Location) | Promise&lt;void&gt; | Updates an existing Location in Supabase using flattened persistence data. | `repo.updateLocation(existingLocation)`
|removeLocation(location) | Promise&lt;void&gt; | Deletes a location by matching the ID from the flattened persistence object. | `repo.removeLocation(locToDelete)`
|===

## Justification for Repository Pattern
The Repository Pattern is used to hide Supabase details behind a clean, domain-focused API. `LocationRepository`` lets the rest of the application work only with `Location`` aggregates instead of raw JSON or SQL-like queries. All persistence logic (CRUD, filters, queries) is centralized in one place, and all data passes through `LocationFactory``, ensuring invariants and validations are always enforced. This makes the codebase easier to change, safer (no invalid `Location`` objects), and more maintainable, since switching database technology or changing the schema only requires updating the repository, not the whole application.

## Example Usage

```ts
...
  useEffect(() => {
      if (locations.length > 0 || openNowFilter) return; // Only run when locations is empty or open now filter was ran and no locations were open
      (async () => {
    
        const locationRepository = new LocationRepository();
        const castedLocations : Location[] = await locationRepository.fetchAllLocations();
        setLocations(castedLocations);
      })();
    }, [locations]);
...
```
